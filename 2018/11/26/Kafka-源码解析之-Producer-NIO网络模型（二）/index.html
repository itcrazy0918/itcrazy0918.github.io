<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录技术路上的点滴"><title>Kafka-源码解析之-Producer NIO网络模型（二） | Steffen's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kafka-源码解析之-Producer NIO网络模型（二）</h1><a id="logo" href="/.">Steffen's Blog</a><p class="description">唐良运</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kafka-源码解析之-Producer NIO网络模型（二）</h1><div class="post-meta">Nov 26, 2018<span> | </span><span class="category"><a href="/categories/大数据/">大数据</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div></div></div><div class="post-content"><p>在写这篇文章之前，专门看了一下 Java NIO 相关的内容，只有理解了 Java NIO 模型才能更好地理解 NIO 在 Kafka 中是如何应用的以及 Producer 如何利用 Java NIO 构建其网络模型（不了解的，可以先看一下上一篇文章：<a href="http://matt33.com/2017/08/12/java-nio/" title="谈一谈 Java IO 模型" target="_blank" rel="noopener">谈一谈 Java IO 模型</a>），同时，本文也是对 Producer 整个流程的一个总结，主要讲述以下两个问题：</p>
<ol>
<li>Producer 的大概网络模型，与 Java NIO 模型之间关系；</li>
<li>Producer 整体流程及其整体流程详解。</li>
</ol>
<p>#Producer 的网络模型</p>
<p>KafkaProducer 通过 Sender 进行相应的 IO 操作，而 Sender 又调用 NetworkClient 来进行 IO 操作，NetworkClient 底层是对 Java NIO 进行相应的封装，其网络模型如下图所示（该图参考：<a href="http://blog.csdn.net/chunlongyu/article/details/52636762" title="Kafka源码深度解析－序列3 －Producer －Java NIO" target="_blank" rel="noopener">Kafka源码深度解析－序列3 －Producer －Java NIO</a>，在其基础上增加一个 KafkaProducer 成员变量的图形）。<br><img src="/2018/11/26/Kafka-源码解析之-Producer-NIO网络模型（二）/producer-network.png" alt="Prodcuer 网络模型"></p>
<p>从图中可以看出，Sender 为最上层的接口，即调用层，Sender 调用 NetworkClient，NetworkClient 调用 Selector，而 Selector 底层封装了 Java NIO 的相关接口，从右边的图也可以看出它们之间的关系。</p>
<p>#Producer 整体流程</p>
<p>有了对 Producer 网络模型的大概框架认识之后，下面再深入进去，看一下它们之间的调用关系以及 Producer 是如何调用 Java NIO 的相关接口，Producer 端的整体流程如下图所示。<br><img src="/2018/11/26/Kafka-源码解析之-Producer-NIO网络模型（二）/producer-nio-flow.png" alt="Producer 整体流程"></p>
<p>这里涉及到的主要方法是：</p>
<ul>
<li><strong>KafkaProducer.dosend()；</strong></li>
<li><strong>Sender.run()；</strong></li>
<li><strong>NetworkClient.poll()（NetworkClient.dosend()）；</strong></li>
<li><strong>Selector.poll()；</strong></li>
</ul>
<p>下面会结合上图，对这几个方法做详细的讲解，本文下面的内容都是结合上图进行讲解。</p>
<p>##KafkaProducer.dosend()</p>
<p>dosend() 方法是 Producer 的入口，dosend() 主要做了两个事情：</p>
<ul>
<li>waitOnMetadata()：请求更新 tp（topic-partition） meta，中间会调用 sender.wakeup()；</li>
<li>accumulator.append()：将 msg 写入到其 tp 对应的 deque 中，如果该 tp 对应的 deque 新建了一个 Batch，最后也会调用 sender.wakeup()。<br>这里主要关注的是 sender.wakeup() 方法，它的作用是将 Sender 线程从阻塞中唤醒。</li>
</ul>
<p>###sender.wakeup() 方法</p>
<p>这里来看一下 sender.wakeup() 具体实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.kafka.clients.producer.internals.Sender</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Wake up the selector associated with this send thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public void wakeup() &#123;</span><br><span class="line">    <span class="keyword">this</span>.client.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.kafka.clients.NetworkClient</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interrupt the client if it is blocked waiting on I/O.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public void wakeup() &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.kafka.common.network.Selector</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interrupt the nioSelector if it is blocked waiting to do I/O.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//note: 如果 selector 是阻塞的话,就唤醒</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public void wakeup() &#123;</span><br><span class="line">    <span class="keyword">this</span>.nioSelector.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法很简单，但也很有意思，其调用过程是下面这个样子：</p>
<ul>
<li>Sender -&gt; NetworkClient -&gt; Selector(Kafka 封装的) -&gt; Selector(Java NIO)</li>
</ul>
<p>跟上面两张图中 KafkaProducer 的总体调用过程大概一致，它的作用就是将 Sender 线程从 select() 方法的阻塞中唤醒，select() 方法的作用是轮询注册在多路复用器上的 Channel，它会一直阻塞在这个方法上，除非满足下面条件中的一个：</p>
<ul>
<li>at least one channel is selected;</li>
<li>this selector’s {@link #wakeup wakeup} method is invoked;</li>
<li>the current thread is interrupted;</li>
<li>the given timeout period expires.</li>
</ul>
<p>否则 select() 将会一直轮询，阻塞在这个地方，直到条件满足。</p>
<p>分析到这里，KafkaProducer 中 dosend() 方法调用 sender.wakeup() 方法作用就很明显的，作用就是：当有新的 RecordBatch 创建后，旧的 RecordBatch 就可以发送了（或者此时有 Metadata 请求需要发送），如果线程阻塞在 select() 方法中，就将其唤醒，Sender 重新开始运行 run() 方法，在这个方法中，旧的 RecordBatch （或相应的 Metadata 请求）将会被选中，进而可以及时将这些请求发送出去。</p>
<p>###Sender.run()</p>
<p>每次循环都是从 Sender 的 run() 方法开始，具体代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//note: Sender 线程每次循环具体执行的地方</span></span><br><span class="line">    void run(long now) &#123;</span><br><span class="line">        <span class="type">Cluster</span> cluster = metadata.fetch();</span><br><span class="line">        <span class="comment">//note: Step1 获取那些已经可以发送的 RecordBatch 对应的 nodes</span></span><br><span class="line">        <span class="type">RecordAccumulator</span>.<span class="type">ReadyCheckResult</span> result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</span><br><span class="line">        <span class="comment">//note: Step2  如果有 topic-partition 的 leader 是未知的,就强制 metadata 更新</span></span><br><span class="line">        <span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">String</span> topic : result.unknownLeaderTopics)</span><br><span class="line">                <span class="keyword">this</span>.metadata.add(topic);</span><br><span class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//note: 如果与node 没有连接（如果可以连接,会初始化该连接）,暂时先移除该 node</span></span><br><span class="line">        <span class="type">Iterator</span>&lt;<span class="type">Node</span>&gt; iter = result.readyNodes.iterator();</span><br><span class="line">        long notReadyTimeout = <span class="type">Long</span>.<span class="type">MAX_VALUE</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">Node</span> node = iter.next();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;<span class="comment">//note: 没有建立连接的 broker,这里会与其建立连接</span></span><br><span class="line">                iter.remove();</span><br><span class="line">                notReadyTimeout = <span class="type">Math</span>.min(notReadyTimeout, <span class="keyword">this</span>.client.connectionDelay(node, now));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//note: Step3  返回该 node 对应的所有可以发送的 RecordBatch 组成的 batches（key 是 node.id,这些 batches 将会在一个 request 中发送）</span></span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">List</span>&lt;<span class="type">RecordBatch</span>&gt;&gt; batches = <span class="keyword">this</span>.accumulator.drain(cluster,</span><br><span class="line">                                                                         result.readyNodes,</span><br><span class="line">                                                                         <span class="keyword">this</span>.maxRequestSize,</span><br><span class="line">                                                                         now);</span><br><span class="line">        <span class="comment">//note: 保证一个 tp 只有一个 RecordBatch 在发送,保证有序性</span></span><br><span class="line">        <span class="comment">//note: max.in.flight.requests.per.connection 设置为1时会保证</span></span><br><span class="line">        <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</span><br><span class="line">            <span class="comment">// Mute all the partitions draine</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">List</span>&lt;<span class="type">RecordBatch</span>&gt; batchList : batches.values()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">RecordBatch</span> batch : batchList)</span><br><span class="line">                    <span class="keyword">this</span>.accumulator.mutePartition(batch.topicPartition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//note: 将由于元数据不可用而导致发送超时的 RecordBatch 移除</span></span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">RecordBatch</span>&gt; expiredBatches = <span class="keyword">this</span>.accumulator.abortExpiredBatches(<span class="keyword">this</span>.requestTimeout, now);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">RecordBatch</span> expiredBatch : expiredBatches)</span><br><span class="line">            <span class="keyword">this</span>.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</span><br><span class="line">        sensors.updateProduceRequestMetrics(batches);</span><br><span class="line">        long pollTimeout = <span class="type">Math</span>.min(result.nextReadyCheckDelayMs, notReadyTimeout);</span><br><span class="line">        <span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</span><br><span class="line">            log.trace(<span class="string">"Nodes with data ready to send: &#123;&#125;"</span>, result.readyNodes);</span><br><span class="line">            pollTimeout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//note: Step4 发送 RecordBatch</span></span><br><span class="line">        sendProduceRequests(batches, now);</span><br><span class="line">        <span class="comment">//note: 如果有 partition 可以立马发送数据,那么 pollTimeout 为0.</span></span><br><span class="line">        <span class="comment">//note: Step5 关于 socket 的一些实际的读写操作</span></span><br><span class="line">        <span class="keyword">this</span>.client.poll(pollTimeout, now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Sender.run()</code> 的大概流程总共有以下五步：</p>
<ol>
<li><p>accumulator.ready()：遍历所有的 tp（topic-partition），如果其对应的 RecordBatch 可以发送（大小达到 <code>batch.size</code> 大小或时间达到 <code>linger.ms</code>），就将其对应的 leader 选出来，最后会返回一个可以发送 Produce request 的 <code>Set&lt;Node&gt;</code>（实际返回的是 ReadyCheckResult 实例，不过 <code>Set&lt;Node&gt;</code> 是最主要的成员变量）；</p>
</li>
<li><p>如果发现有 tp 没有 leader，那么这里就调用 <code>requestUpdate()</code> 方法更新 metadata，实际上还是在第一步对 tp 的遍历中，遇到没有 leader 的 tp 就将其加入到一个叫做 unknownLeaderTopics 的 set 中，然后会请求这个 tp 的 meta（meta 的更新策略可以参考之前的一篇博客 <a href="http://matt33.com/2017/07/08/kafka-producer-metadata/#Producer-Metadata-%E7%9A%84%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5" title="Producer Metadata 的更新策略" target="_blank" rel="noopener">Producer Metadata 的更新策略</a>）；</p>
</li>
<li><p>accumulator.drain()：遍历每个 leader （第一步中选出）上的所有 tp，如果该 tp 对应的 RecordBatch 不在 backoff 期间（没有重试过，或者重试了但是间隔已经达到了 retryBackoffMs ），并且加上这个 RecordBatch 其大小不超过 maxSize（一个 request 的最大限制，默认为 1MB），那么就把这个 RecordBatch 添加 list 中，最终返回的类型为 <code>Map&lt;Integer, List&lt;RecordBatch&gt;&gt;</code>，key 为 leader.id，value 为要发送的 RecordBatch 的列表；</p>
</li>
<li><p>sendProduceRequests()：发送 Produce 请求，从图中，可以看出，这个方法会调用 NetworkClient.send() 来发送 clientRequest；</p>
</li>
<li><p>NetworkClient.poll()：关于 socket 的 IO 操作都是在这个方法进行的，它还是调用 Selector 进行的相应操作，而 Selector 底层则是封装的 Java NIO 的相关接口，这个下面会详细讲述。</p>
</li>
</ol>
<p>在第三步中，可以看到，如果要向一个 leader 发送 Produce 请求，那么这 leader 对应 tp，如果其 RecordBatch 没有达到要求（batch.size 或 linger.ms 都没达到）还是可能会发送，这样做的好处是：可以减少 request 的频率，有利于提供发送效率。</p>
<p>###NetworkClient.poll()</p>
<p>这个方法也是一个非常重要的方法，其作用简单来说有三点：</p>
<ul>
<li>如果需要更新 Metadata，那么就发送 Metadata 请求；</li>
<li>调用 Selector 进行相应的 IO 操作；</li>
<li>处理 Server 端的 response 及一些其他的操作。</li>
</ul>
<p>具体代码如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">List</span>&lt;<span class="type">ClientResponse</span>&gt; poll(long timeout, long now) &#123;</span><br><span class="line">        <span class="comment">//note: Step1 判断是否需要更新 meta,如果需要就更新（请求更新 metadata 的地方）</span></span><br><span class="line">        long metadataTimeout = metadataUpdater.maybeUpdate(now);</span><br><span class="line">        <span class="comment">//note: Step2 调用 Selector.poll() 进行 socket 相关的 IO 操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.selector.poll(<span class="type">Utils</span>.min(timeout, metadataTimeout, requestTimeoutMs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> e) &#123;</span><br><span class="line">            log.error(<span class="string">"Unexpected error during I/O"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//note: Step3 处理完成后的操作</span></span><br><span class="line">        long updatedNow = <span class="keyword">this</span>.time.milliseconds();</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">ClientResponse</span>&gt; responses = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        handleAbortedSends(responses);</span><br><span class="line">        <span class="comment">//note: 处理已经完成的 send（不需要 response 的 request,如 send）</span></span><br><span class="line">        handleCompletedSends(responses, updatedNow);<span class="comment">//note: 通过 selector 中获取 Server 端的 response</span></span><br><span class="line">        <span class="comment">//note: 处理从 server 端接收到 Receive（如 Metadata 请求）</span></span><br><span class="line">        handleCompletedReceives(responses, updatedNow);<span class="comment">//note: 在返回的 handler 中，会处理 metadata 的更新</span></span><br><span class="line">        <span class="comment">//note: 处理连接失败那些连接,重新请求 meta</span></span><br><span class="line">        handleDisconnections(responses, updatedNow);</span><br><span class="line">        <span class="comment">//note: 处理新建立的那些连接（还不能发送请求,比如:还未认证）</span></span><br><span class="line">        handleConnections();</span><br><span class="line">        handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">        handleTimedOutRequests(responses, updatedNow);</span><br><span class="line">        <span class="comment">// invoke callbacks</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ClientResponse</span> response : responses) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.onComplete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">                log.error(<span class="string">"Uncaught error in request completion:"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responses;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法大致分为三步，这里详述讲述一下：</p>
<ol>
<li>metadataUpdater.maybeUpdate()：如果 Metadata 需要更新，那么就选择连接数最小的 node，发送 Metadata 请求，详细流程可以参考之前那篇博客<a href="http://matt33.com/2017/07/08/kafka-producer-metadata/#Producer-%E7%9A%84-Metadata-%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B" title="Producer 的 Metadata 更新流程" target="_blank" rel="noopener">Producer 的 Metadata 更新流程</a>；</li>
<li>selector.poll()：进行 socket IO 相关的操作，下面会详细讲述；</li>
<li>process completed actions：在一个 select() 过程之后的相关处理。<ul>
<li>handleAbortedSends(responses)：处理那么在发送过程出现 UnsupportedVersionException 异常的 request；</li>
<li>handleCompletedSends(responses, updatedNow)：处理那些已经完成的 request，如果是那些不需要 response 的 request 的话，这里直接调用 request.completed()，标志着这个 request 发送处理完成；</li>
<li>handleCompletedReceives(responses, updatedNow)：处理那些从 Server 端接收的 Receive，metadata 更新就是在这里处理的（以及 ApiVersionsResponse）；</li>
<li>handleDisconnections(responses, updatedNow)：处理连接失败那些连接,重新请求 metadata；</li>
<li>handleConnections()：处理新建立的那些连接（还不能发送请求,比如:还未认证）；</li>
<li>handleInitiateApiVersionRequests(updatedNow)：对那些新建立的连接，发送 apiVersionRequest（默认情况：第一次建立连接时，需要向 Broker 发送 ApiVersionRequest 请求）；</li>
<li>handleTimedOutRequests(responses, updatedNow)：处理 timeout 的连接，关闭该连接，并刷新 Metadata。</li>
</ul>
</li>
</ol>
<p>###Selector.poll()<br>  Selector 类是 Kafka 对 Java NIO 相关接口的封装，socket IO 相关的操作都是这个类中完成的，这里先看一下 poll() 方法，主要的操作都是这个方法中调用的，其代码实现如下：<br>  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void poll(long timeout) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"timeout should be &gt;= 0"</span>);</span><br><span class="line">        <span class="comment">//note: Step1 清除相关记录</span></span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">if</span> (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty())</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* check ready keys */</span></span><br><span class="line">        <span class="comment">//note: Step2 获取就绪事件的数</span></span><br><span class="line">        long startSelect = time.nanoseconds();</span><br><span class="line">        int readyKeys = select(timeout);</span><br><span class="line">        long endSelect = time.nanoseconds();</span><br><span class="line">        <span class="keyword">this</span>.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());</span><br><span class="line">        <span class="comment">//note: Step3 处理 io 操作</span></span><br><span class="line">        <span class="keyword">if</span> (readyKeys &gt; <span class="number">0</span> || !immediatelyConnectedKeys.isEmpty()) &#123;</span><br><span class="line">            pollSelectionKeys(<span class="keyword">this</span>.nioSelector.selectedKeys(), <span class="literal">false</span>, endSelect);</span><br><span class="line">            pollSelectionKeys(immediatelyConnectedKeys, <span class="literal">true</span>, endSelect);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//note: Step4 将处理得到的 stagedReceives 添加到 completedReceives 中</span></span><br><span class="line">        addToCompletedReceives();</span><br><span class="line">        long endIo = time.nanoseconds();</span><br><span class="line">        <span class="keyword">this</span>.sensors.ioTime.record(endIo - endSelect, time.milliseconds());</span><br><span class="line">        <span class="comment">// we use the time at the end of select to ensure that we don't close any connections that</span></span><br><span class="line">        <span class="comment">// have just been processed in pollSelectionKeys</span></span><br><span class="line">        <span class="comment">//note: 每次 poll 之后会调用一次</span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 连接虽然关闭了,但是 Client 端的缓存依然存在</span></span><br><span class="line">        maybeCloseOldestConnection(endSelect);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>  Selector.poll() 方法会进行四步操作，这里分别来介绍一些。</p>
<p>####clear()</p>
<p>  clear() 方法是在每次 poll() 执行的第一步，它作用的就是清理上一次 poll 过程产生的部分缓存。<br>  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//note: 每次 poll 调用前都会清除以下缓存</span></span><br><span class="line"><span class="keyword">private</span> void clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.completedSends.clear();</span><br><span class="line">    <span class="keyword">this</span>.completedReceives.clear();</span><br><span class="line">    <span class="keyword">this</span>.connected.clear();</span><br><span class="line">    <span class="keyword">this</span>.disconnected.clear();</span><br><span class="line">    <span class="comment">// Remove closed channels after all their staged receives have been processed or if a send was requested</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Iterator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">String</span>, <span class="type">KafkaChannel</span>&gt;&gt; it = closingChannels.entrySet().iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        <span class="type">KafkaChannel</span> channel = it.next().getValue();</span><br><span class="line">        <span class="type">Deque</span>&lt;<span class="type">NetworkReceive</span>&gt; deque = <span class="keyword">this</span>.stagedReceives.get(channel);</span><br><span class="line">        boolean sendFailed = failedSends.remove(channel.id());</span><br><span class="line">        <span class="keyword">if</span> (deque == <span class="literal">null</span> || deque.isEmpty() || sendFailed) &#123;</span><br><span class="line">            doClose(channel, <span class="literal">true</span>);</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.disconnected.addAll(<span class="keyword">this</span>.failedSends);</span><br><span class="line">    <span class="keyword">this</span>.failedSends.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####select()</p>
<p>  Selector 的 select() 方法在实现上底层还是调用 Java NIO 原生的接口，这里的 nioSelector 其实就是 java.nio.channels.Selector 的实例对象，这个方法最坏情况下，会阻塞 ms 的时间，如果在一次轮询，只要有一个 Channel 的事件就绪，它就会立马返回。<br>  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> int select(long ms) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms &lt; <span class="number">0</span>L)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"timeout should be &gt;= 0"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ms == <span class="number">0</span>L)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nioSelector.selectNow();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nioSelector.select(ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####pollSelectionKeys()</p>
<p>  这部分是 socket IO 的主要部分，发送 Send 及接收 Receive 都是在这里完成的，在 poll() 方法中，这个方法会调用两次：</p>
<ol>
<li>第一次调用的目的是：处理已经就绪的事件，进行相应的 IO 操作；</li>
<li><p>第二次调用的目的是：处理新建立的那些连接，添加缓存及传输层（Kafka 又封装了一次，这里后续文章会讲述）的握手与认证。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void pollSelectionKeys(<span class="type">Iterable</span>&lt;<span class="type">SelectionKey</span>&gt; selectionKeys,</span><br><span class="line">                                   boolean isImmediatelyConnected,</span><br><span class="line">                                   long currentTimeNanos) &#123;</span><br><span class="line">        <span class="type">Iterator</span>&lt;<span class="type">SelectionKey</span>&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">SelectionKey</span> key = iterator.next();</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="type">KafkaChannel</span> channel = channel(key);</span><br><span class="line">            <span class="comment">// register all per-connection metrics at once</span></span><br><span class="line">            sensors.maybeRegisterConnectionMetrics(channel.id());</span><br><span class="line">            <span class="keyword">if</span> (idleExpiryManager != <span class="literal">null</span>)</span><br><span class="line">                idleExpiryManager.update(channel.id(), currentTimeNanos);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/* complete any connections that have finished their handshake (either normally or immediately) */</span></span><br><span class="line">                <span class="comment">//note: 处理一些刚建立 tcp 连接的 channel</span></span><br><span class="line">                <span class="keyword">if</span> (isImmediatelyConnected || key.isConnectable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (channel.finishConnect()) &#123;<span class="comment">//note: 连接已经建立</span></span><br><span class="line">                        <span class="keyword">this</span>.connected.add(channel.id());</span><br><span class="line">                        <span class="keyword">this</span>.sensors.connectionCreated.record();</span><br><span class="line">                        <span class="type">SocketChannel</span> socketChannel = (<span class="type">SocketChannel</span>) key.channel();</span><br><span class="line">                        log.debug(<span class="string">"Created socket with SO_RCVBUF = &#123;&#125;, SO_SNDBUF = &#123;&#125;, SO_TIMEOUT = &#123;&#125; to node &#123;&#125;"</span>,</span><br><span class="line">                                socketChannel.socket().getReceiveBufferSize(),</span><br><span class="line">                                socketChannel.socket().getSendBufferSize(),</span><br><span class="line">                                socketChannel.socket().getSoTimeout(),</span><br><span class="line">                                channel.id());</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* if channel is not ready finish prepare */</span></span><br><span class="line">                <span class="comment">//note: 处理 tcp 连接还未完成的连接,进行传输层的握手及认证</span></span><br><span class="line">                <span class="keyword">if</span> (channel.isConnected() &amp;&amp; !channel.ready())</span><br><span class="line">                    channel.prepare();</span><br><span class="line">                <span class="comment">/* if channel is ready read from any connections that have readable data */</span></span><br><span class="line">                <span class="keyword">if</span> (channel.ready() &amp;&amp; key.isReadable() &amp;&amp; !hasStagedReceive(channel)) &#123;</span><br><span class="line">                    <span class="type">NetworkReceive</span> networkReceive;</span><br><span class="line">                    <span class="keyword">while</span> ((networkReceive = channel.read()) != <span class="literal">null</span>)<span class="comment">//note: 知道读取一个完整的 Receive,才添加到集合中</span></span><br><span class="line">                        addToStagedReceives(channel, networkReceive);<span class="comment">//note: 读取数据</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* if channel is ready write to any sockets that have space in their buffer and for which we have data */</span></span><br><span class="line">                <span class="keyword">if</span> (channel.ready() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">                    <span class="type">Send</span> send = channel.write();</span><br><span class="line">                    <span class="keyword">if</span> (send != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.completedSends.add(send);<span class="comment">//note: 将完成的 send 添加到 list 中</span></span><br><span class="line">                        <span class="keyword">this</span>.sensors.recordBytesSent(channel.id(), send.size());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* cancel any defunct sockets */</span></span><br><span class="line">                <span class="comment">//note: 关闭断开的连接</span></span><br><span class="line">                <span class="keyword">if</span> (!key.isValid())</span><br><span class="line">                    close(channel, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">                <span class="type">String</span> desc = channel.socketDescription();</span><br><span class="line">                <span class="keyword">if</span> (e instanceof <span class="type">IOException</span>)</span><br><span class="line">                    log.debug(<span class="string">"Connection with &#123;&#125; disconnected"</span>, desc, e);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    log.warn(<span class="string">"Unexpected error from &#123;&#125;; closing connection"</span>, desc, e);</span><br><span class="line">                close(channel, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>####addToCompletedReceives()</p>
<p>  这个方法的目的是处理接收到的 Receive，由于 Selector 这个类在 Client 和 Server 端都会调用，这里分两种情况讲述一下：</p>
<ol>
<li>应用在 Server 端时，后续文章会详细介绍，这里简单说一下，Server 为了保证消息的时序性，在 Selector 中提供了两个方法：mute(String id) 和 unmute(String id)，对该 KafkaChannel 做标记来保证同时只能处理这个 Channel 的一个 request（可以理解为排它锁）。当 Server 端接收到 request 后，先将其放入 stagedReceives 集合中，此时该 Channel 还未 mute，这个 Receive 会被放入 completedReceives 集合中。Server 在对 completedReceives 集合中的 request 进行处理时，会先对该 Channel mute，处理后的 response 发送完成后再对该 Channel unmute，然后才能处理该 Channel 其他的请求；</li>
<li><p>应用在 Client 端时，Client 并不会调用 Selector 的 mute() 和 unmute() 方法，client 的时序性而是通过 InFlightRequests 和 RecordAccumulator 的 mutePartition 来保证的（下篇文章会讲述），因此对于 Client 端而言，这里接收到的所有 Receive 都会被放入到 completedReceives 的集合中等待后续处理。</p>
<p>这个方法只有配合 Server 端的调用才能看明白其作用，它统一 Client 和 Server 调用的 api，使得都可以使用 Selector 这个类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * checks if there are any staged receives and adds to completedReceives</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> void addToCompletedReceives() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.stagedReceives.isEmpty()) &#123;<span class="comment">//note: 处理 stagedReceives</span></span><br><span class="line">        <span class="type">Iterator</span>&lt;<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">KafkaChannel</span>, <span class="type">Deque</span>&lt;<span class="type">NetworkReceive</span>&gt;&gt;&gt; iter = <span class="keyword">this</span>.stagedReceives.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">KafkaChannel</span>, <span class="type">Deque</span>&lt;<span class="type">NetworkReceive</span>&gt;&gt; entry = iter.next();</span><br><span class="line">            <span class="type">KafkaChannel</span> channel = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (!channel.isMute()) &#123;</span><br><span class="line">                <span class="type">Deque</span>&lt;<span class="type">NetworkReceive</span>&gt; deque = entry.getValue();</span><br><span class="line">                addToCompletedReceives(channel, deque);</span><br><span class="line">                <span class="keyword">if</span> (deque.isEmpty())</span><br><span class="line">                    iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> void addToCompletedReceives(<span class="type">KafkaChannel</span> channel, <span class="type">Deque</span>&lt;<span class="type">NetworkReceive</span>&gt; stagedDeque) &#123;</span><br><span class="line">    <span class="type">NetworkReceive</span> networkReceive = stagedDeque.poll();</span><br><span class="line">    <span class="keyword">this</span>.completedReceives.add(networkReceive); <span class="comment">//note: 添加到 completedReceives 中</span></span><br><span class="line">    <span class="keyword">this</span>.sensors.recordBytesReceived(channel.id(), networkReceive.payload().limit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>##Network.send() 方法</p>
<p>至此，文章的主要内容已经讲述得差不多了，第二张图中最上面的那个调用关系已经讲述完，下面讲述一下另外一个小分支，也就是从 Sender.run() 调用 NetworkClient.send() 开始的那部分，其调用过程如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Sender</span>.run()</span><br><span class="line"><span class="type">Sender</span>.sendProduceRequests()</span><br><span class="line"><span class="type">NetworkClient</span>.send()</span><br><span class="line"><span class="type">NetworkClient</span>.dosend()</span><br><span class="line"><span class="type">Selector</span>.send()</span><br><span class="line"><span class="type">KafkaChannel</span>.setSend()</span><br></pre></td></tr></table></figure></p>
<p>####NetworkClient.dosend()<br>Producer 端的请求都是通过 NetworkClient.dosend() 来发送的，其作用就是：</p>
<ol>
<li>检查版本信息，并根据 apiKey() 构建 Request；</li>
<li>创建 NetworkSend 实例；</li>
<li>调用 Selector.send 发送该 Send。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//note: 发送请求</span></span><br><span class="line">    <span class="keyword">private</span> void doSend(<span class="type">ClientRequest</span> clientRequest, boolean isInternalRequest, long now) &#123;</span><br><span class="line">        <span class="type">String</span> nodeId = clientRequest.destination();</span><br><span class="line">        <span class="keyword">if</span> (!isInternalRequest) &#123;</span><br><span class="line">            <span class="comment">// If this request came from outside the NetworkClient, validate</span></span><br><span class="line">            <span class="comment">// that we can send data.  If the request is internal, we trust</span></span><br><span class="line">            <span class="comment">// that that internal code has done this validation.  Validation</span></span><br><span class="line">            <span class="comment">// will be slightly different for some internal requests (for</span></span><br><span class="line">            <span class="comment">// example, ApiVersionsRequests can be sent prior to being in</span></span><br><span class="line">            <span class="comment">// READY state.)</span></span><br><span class="line">            <span class="keyword">if</span> (!canSendRequest(nodeId))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Attempt to send a request to node "</span> + nodeId + <span class="string">" which is not ready."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">AbstractRequest</span> request = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">AbstractRequest</span>.<span class="type">Builder</span>&lt;?&gt; builder = clientRequest.requestBuilder();</span><br><span class="line">        <span class="comment">//note: 构建 AbstractRequest, 检查其版本信息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">NodeApiVersions</span> versionInfo = nodeApiVersions.get(nodeId);</span><br><span class="line">            <span class="comment">// Note: if versionInfo is null, we have no server version information. This would be</span></span><br><span class="line">            <span class="comment">// the case when sending the initial ApiVersionRequest which fetches the version</span></span><br><span class="line">            <span class="comment">// information itself.  It is also the case when discoverBrokerVersions is set to false.</span></span><br><span class="line">            <span class="keyword">if</span> (versionInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (discoverBrokerVersions &amp;&amp; log.isTraceEnabled())</span><br><span class="line">                    log.trace(<span class="string">"No version information found when sending message of type &#123;&#125; to node &#123;&#125;. "</span> +</span><br><span class="line">                            <span class="string">"Assuming version &#123;&#125;."</span>, clientRequest.apiKey(), nodeId, builder.version());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                short version = versionInfo.usableVersion(clientRequest.apiKey());</span><br><span class="line">                builder.setVersion(version);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The call to build may also throw UnsupportedVersionException, if there are essential</span></span><br><span class="line">            <span class="comment">// fields that cannot be represented in the chosen version.</span></span><br><span class="line">            request = builder.build();<span class="comment">//note: 当为 Produce 请求时,转化为 ProduceRequest,Metadata 请求时,转化为 Metadata 请求</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">UnsupportedVersionException</span> e) &#123;</span><br><span class="line">            <span class="comment">// If the version is not supported, skip sending the request over the wire.</span></span><br><span class="line">            <span class="comment">// Instead, simply add it to the local queue of aborted requests.</span></span><br><span class="line">            log.debug(<span class="string">"Version mismatch when attempting to send &#123;&#125; to &#123;&#125;"</span>,</span><br><span class="line">                    clientRequest.toString(), clientRequest.destination(), e);</span><br><span class="line">            <span class="type">ClientResponse</span> clientResponse = <span class="keyword">new</span> <span class="type">ClientResponse</span>(clientRequest.makeHeader(),</span><br><span class="line">                    clientRequest.callback(), clientRequest.destination(), now, now,</span><br><span class="line">                    <span class="literal">false</span>, e, <span class="literal">null</span>);</span><br><span class="line">            abortedSends.add(clientResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RequestHeader</span> header = clientRequest.makeHeader();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            int latestClientVersion = <span class="type">ProtoUtils</span>.latestVersion(clientRequest.apiKey().id);</span><br><span class="line">            <span class="keyword">if</span> (header.apiVersion() == latestClientVersion) &#123;</span><br><span class="line">                log.trace(<span class="string">"Sending &#123;&#125; to node &#123;&#125;."</span>, request, nodeId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Using older server API v&#123;&#125; to send &#123;&#125; to node &#123;&#125;."</span>,</span><br><span class="line">                    header.apiVersion(), request, nodeId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//note: Send是一个接口，这里返回的是 NetworkSend，而 NetworkSend 继承 ByteBufferSend</span></span><br><span class="line">        <span class="type">Send</span> send = request.toSend(nodeId, header);</span><br><span class="line">        <span class="type">InFlightRequest</span> inFlightRequest = <span class="keyword">new</span> <span class="type">InFlightRequest</span>(</span><br><span class="line">                header,</span><br><span class="line">                clientRequest.createdTimeMs(),</span><br><span class="line">                clientRequest.destination(),</span><br><span class="line">                clientRequest.callback(),</span><br><span class="line">                clientRequest.expectResponse(),</span><br><span class="line">                isInternalRequest,</span><br><span class="line">                send,</span><br><span class="line">                now);</span><br><span class="line">        <span class="keyword">this</span>.inFlightRequests.add(inFlightRequest);</span><br><span class="line">        <span class="comment">//note: 将 send 和对应 kafkaChannel 绑定起来，并开启该 kafkaChannel 底层 socket 的写事件</span></span><br><span class="line">        selector.send(inFlightRequest.send);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>####Selector.send()<br>这个方法就比较容易理解了，它的作用就是获取该 Send 对应的 KafkaChannel，调用 setSend() 向 KafkaChannel 注册一个 Write 事件。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//note: 发送请求</span></span><br><span class="line">public void send(<span class="type">Send</span> send) &#123;</span><br><span class="line">    <span class="type">String</span> connectionId = send.destination();</span><br><span class="line">    <span class="keyword">if</span> (closingChannels.containsKey(connectionId))</span><br><span class="line">        <span class="keyword">this</span>.failedSends.add(connectionId);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">KafkaChannel</span> channel = channelOrFail(connectionId, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.setSend(send);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">CancelledKeyException</span> e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.failedSends.add(connectionId);</span><br><span class="line">            close(channel, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###KafkaChannel.setSend()<br>setSend() 方法需要配合 write()（该方法是在 Selector.poll() 中调用的） 方法一起来看</p>
<ul>
<li>setSend()：将当前 KafkaChannel 的 Send 赋值为要发送的 Send，并注册一个 OP_WRITE 事件；</li>
<li>write()：发送当前的 Send，发送完后删除注册的 OP_WRITE 事件。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//note: 每次调用时都会注册一个 OP_WRITE 事件</span></span><br><span class="line">public void setSend(<span class="type">Send</span> send) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.send != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Attempt to begin a send operation with prior send operation still in progress."</span>);</span><br><span class="line">    <span class="keyword">this</span>.send = send;</span><br><span class="line">    <span class="keyword">this</span>.transportLayer.addInterestOps(<span class="type">SelectionKey</span>.<span class="type">OP_WRITE</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//note: 调用 send() 发送 Send</span></span><br><span class="line">public <span class="type">Send</span> write() <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">    <span class="type">Send</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (send != <span class="literal">null</span> &amp;&amp; send(send)) &#123;</span><br><span class="line">        result = send;</span><br><span class="line">        send = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//note: 发送完成后,就删除这个 WRITE 事件</span></span><br><span class="line"><span class="keyword">private</span> boolean send(<span class="type">Send</span> send) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">    send.writeTo(transportLayer);</span><br><span class="line">    <span class="keyword">if</span> (send.completed())</span><br><span class="line">        transportLayer.removeInterestOps(<span class="type">SelectionKey</span>.<span class="type">OP_WRITE</span>);</span><br><span class="line">    <span class="keyword">return</span> send.completed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，简单总结一下，可以回过头再看一下第一张图，对于 KafkaProducer 而言，其直接调用是 Sender，而 Sender 底层调用的是 NetworkClient，NetworkClient 则是通过 Selector 实现，Selector 则是对 Java NIO 原生接口的封装。</p>
<p>参考文献：</p>
<ul>
<li><a href="http://blog.csdn.net/chunlongyu/article/details/52636762" title="Kafka源码深度解析－序列3 －Producer －Java NIO" target="_blank" rel="noopener">Kafka源码深度解析－序列3 －Producer －Java NIO</a></li>
<li><a href="http://blog.csdn.net/chunlongyu/article/details/52651960" title="Kafka源码深度解析－序列4 －Producer －network层核心原理" target="_blank" rel="noopener">Kafka源码深度解析－序列4 －Producer －network层核心原理</a></li>
</ul>
</div><div class="tags"><a href="/tags/kafka/">kafka</a></div><div class="post-nav"><a class="pre" href="/2018/11/26/Kafka-最佳实践之-Broker-性能调优（一）/">Kafka-最佳实践之-Broker-性能调优（一）</a><a class="next" href="/2018/11/24/Kafka-源码解析之-Server-1-N-M-网络处理模型（一）/">Kafka 源码解析之 Server 1+N+M 网络处理模型（一）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://yoursite.com"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/kafka/" style="font-size: 15px;">kafka</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/02/21/Kafka-源码解析之-Broker-文件存储（三）/">Kafka-源码解析之-Broker文件存储（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/Kafka-最佳实践之-Producer-性能调优（二）/">Kafka-最佳实践之-Producer-性能调优（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/Kafka-最佳实践之-Broker-性能调优（一）/">Kafka-最佳实践之-Broker-性能调优（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/Kafka-源码解析之-Producer-NIO网络模型（二）/">Kafka-源码解析之-Producer NIO网络模型（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/24/Kafka-源码解析之-Server-1-N-M-网络处理模型（一）/">Kafka 源码解析之 Server 1+N+M 网络处理模型（一）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://tech.meituan.com/" title="美团技术博客" target="_blank">美团技术博客</a><ul></ul><a href="http://jm.taobao.org/categories/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://lxw1234.com/" title="lxw的技术天地" target="_blank">lxw的技术天地</a><ul></ul><a href="http://hbasefly.com/" title="范欣欣~有态度的HBase" target="_blank">范欣欣~有态度的HBase</a><ul></ul><a href="http://orchome.com" title="Kafka技术博客~OrcHome" target="_blank">Kafka技术博客~OrcHome</a><ul></ul><a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=4260364" title="Elasticsearch 5.4 中文文档" target="_blank">Elasticsearch 5.4 中文文档</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Steffen's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>